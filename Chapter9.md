# Chapter 9 構造化言語とオープンシステム
## 9.2
### 9.2.4 システムプログラム ソケット通信の例
C言語では、TCP/IPを使用したソケット通信をサポートしている。
#### ソケット方式について
  ```
  socket()->bind()->listen()->accept()------->read()--------->write()       サーバ側
				       |        |　　　　　　　	|
			       接続確立|	|データ要求	|データ応答
				       |	|		|
		    　　　socket()->connect()->write()-------->read()       クライアント側
  ```
  
ソケット通信では、クライアント/サーバ側の通信方式が代表的で、
1. クライアントはサーバに対して、任意のタイミングでリクエストを送り(クライアント側`write()`)
1. サーバではクライアントから任意のタイミングで送られてくるリクエストを待ち受ける

この通信方式はネットワークを使用するアプリケーションでの基本パターン

ソケットを使用した通信方式には、当初バークレイ系のUnixから実装された
- バークレイソケット：Unix <-こっちが主流
- TLI(Transport Layer interface)：SystemV系



### バークレイソケットを使用したプログラム例

```c:client.c
#include <sys/types.h>
#include <sys/socket.h>
#include <stdio.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <stdlib.h>

int main(int argc, char **argv) {
  int sockfd, len, res;
  struct sockaddr_in addr;
  char *send = *(++argv); char recv[80];
  sockfd = socket(AF_INET, SOCK_STREAM, 0);//ソケットシステムコール
  addr.sin_family = AF_INET;
  addr.sin_addr.s_addr = inet_addr("127.0.0.1");
  addr.sin_port = 9374;
  len = sizeof(addr);
  res = connect(sockfd, (struct sockaddr *)&addr, len);
  if (res == -1) {
    printf("client error");
    exit(1);
  }
  write(sockfd, send, 80);
  read(sockfd, recv, 80);
  printf("サーバからの応答 = %s\n", recv);
  close(sockfd);
  exit(0);
  return 0;
}
```

#### `socket()`システムコール
クライアントからサーバにアクセスする場合、最初にsocketシステムコールでソケットを生成する  

#### `connect()`システムコール
`socket()`コールで通信方式を指定したあと、クライアントは`connect`コールでサーバへの接続確立のリクエストを送信する。

#### `write()`システムコール
`connect`コールの戻り値からサーバとの接続が角煮されるとサーバへのデータ送信が可能になり、`write()`コールでサーバへデータを送信する

#### `read()`システムコール
`write`コールはサーバへのリクエスト送信となり、サーバからのレスポンスを`read`コールで受信する

```c:server.c
#include <sys/types.h>
#include <sys/socket.h>
#include <stdio.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <string.h>
int main(){
  int server_sockfd, client_sockfd;
  int server_len, client_len;
  struct sockaddr_in server_address;
  struct sockaddr_in client_address;
  server_sockfd = socket(AF_INET, SOCK_STREAM, 0);
  server_address.sin_family = AF_INET;
  server_address.sin_addr.s_addr = inet_addr("127.0.0.1");
  server_address.sin_port = 9374;
  server_len = sizeof(server_address);
  bind(server_sockfd, (struct sockaddr *) &server_address, server_len);
  listen(server_sockfd, 5);

  for(;;) {
    char msg[80]; printf("server waiting\n");
    client_sockfd = accept(server_sockfd, (struct sockaddr *)&client_address, &client_len);
    read(client_sockfd, msg, 80);
    strcat(msg, " Yes We can!\n");
    write(client_sockfd, msg, 80);
    close(client_sockfd);
  }
}
```

#### `socket()`システムコール
サーバ側でもクライアント同様に`socket`コールを最初に実行し、そのあと`bind`コールを実行する

#### `bind()`システムコール
`bind`コールは、`server_address`で指定されたアドレスを割り当てる。

#### `listen()`システムコール
コネクションの確立時にクライアント側からの接続要求を格納するキューを作成する。

## 9.3 C言語でのコンパイラの仕組み
### アセンブリ言語と高級言語

| アセンブリ言語 | C言語 |
|:-:|:-:|
| 低級言語 | 高級言語 |
| アセンブリ言語を経由してから、マシンコードに変換 | |
| CPUにとって理解しやすい形式 | 人間にとって理解と記述が容易な形式 |
| 特定のCPUに依存した処理が必要 | 抽象化が進んでいるため、CPUに依存しない |

### マシンコードとアセンブラ
- **コンパイラ・ビルド**：高級言語をマシンコードに変換する仕組み
- **オブジェクトコード**：ソースコードをコンパイラに入力して生成されるプログラム(マシンコード)
  - インタープリタ：コンパイル過程を経ることなく、ソースコードから直接実行可能なインタプリタ言語。(多くの場合、インタプリタを介した実行よりもオブジェクトコードを使った実行の方が高速)
- コンパイラに入力されるソースコードだけでは、プログラムの実行ができずに、多くの場合は外部ライブラリの参照指定が含まれる

### コンパイラの仕組み

1. `cpp`：Cプリプロセッサ   
1. `ccl`：コンパイラ本体(アセンブラのソース、`abc.s`を出力)
1. `as`：アセンブラ(リロケータブルオブジェクト`abc.o`を出力)
1. `ld`：リンカ(`abc.o`とライブラリをリンクし、実行形式バイナリを生成)


1. `cpp`：Cプリプロセッサ
   ```c:hello.c
   #include <stdio.h>
   
   void main() {
     printf("Hello, World!\n");
   }
   ```
   
   - gcc：GNUプロジェクトいよって作られたC言語コンパイラ
   
   ```
   $ gcc -E hello.c > hello-e.c
   ```
   
   と入力すると、`hello.c`のソースファイルから、`hello.s`というファイルが生成さ

1. `ccl`：コンパイラ本体。
   - プリプロセッサ処理ではコンパイル対象のC言語ソースコードをすべて揃えてからコンパイル本体に渡す。コンパイラ本体は、プリプロセッサから渡されたソースコードをアセンブラに変換する。

   1. 単語解析：コンパイラでは、最初にソースコードを読み込んで、単語解析を行う。単語解析では、読み込んだソースコードを解析して、プログラム記述の基本要素(**トークン**)に分割される。
   1. 構文解析：プログラムがトークンに分割されると、コンパイラは文の構造を認識するための処理を行う。
   1. 意味解析：構文解析->意味解析の手順を繰り返しながら実行される。
   1. コード最適化
     - CPUに依存しない最適化：1つのプログラムで2回以上繰り返すような処理が出てきた場合は、2回目以降の文を省略し、すべての最初の文を参照するようにする
     - CPUに依存する最適化：CPUよりレジスタの数が異なる場合の対応や、そのCPUのアセンブリ言語特製に依存するように処理内容を変更するなど
   1. アセンブリコードの生成：オブジェクトコードの生成。
     ```
     $ gcc -S hello.c [Enter]
     ```
     と入力すると、`hello.c`のソースファイルから`hello.s`というファイルが生成され、その内容が以下のようになる。
   
     ```s
     .file "yes.c"
   	 .section .rodata
     .LC0:
	 .string "Hello, World!"
	 .text 
	 .globl main
   	 .type main, @function 
     main:
	 leal 4(%esp), %ecx
	 andl $-16, %esp
	 pushl -4(%ecx)
	 pushl %ebp
	 movl %esp, %ebp
	 pushl %ecx
	 subl $4, %esp 
	 movl $.LC0, (%esp) 
	 call puts
	 addl $4, %esp
	 popl %ecx
	 popl %ebp
	 leal -4(%ecx), %esp
	 ret
	 .size main, .-main
	 .ident "GCC: (GNU) 4.1.0 20060304 (Red Hat 4.1.0-3)" 
	 .section .note.GNU-stack,"",@
     ```
 1. アセンブラ。コンパイラ本体処理で生成されたアセンブリ命令のソースコードをアセンブルし、該当CPUのマシンコードを含んだバイナリファイルを出力する。
    ```
    gcc -c hello.c [Enter]
    ```
    の入力で、リロケータブルオブジェクトファイル(`hello.o`)が出力される。  

    このファイルはマシンコードのバイナリファイルであるため、通常のエディタでは、意味のある表示ができない。
    ```
    objdump -d hello.o > hello-r
    ```
1. リンカ：アセンブラが出力したリロケータブルオブジェクトファイルを`libc`や他の必要なライブラリおよびCランタイムルーチンとリンクとして、実行可能なバイナリファイルの形式にして出力


## BASIC
### 非構造化言語と構造化言語の中間言語
- **BASIC(Begginer's All purpose Symbolic Instruction Code)**：これまでに最も使用された言語

- メインフレーム集中の問題点
  - 各部署のシステム化や企業の競争力を高めるために、システムを常に修正・機能追加していくことが要求されるが、メインフレームでは、到底ユーザ部門からの要求に満足できるような対応は不可能
  - ゆーzあ部門からのリクエストに対するバックログの多さが問題視される
-> この問題に対する解決策：**エンドユーザコンピューティング**

#### エンドユーザコンピューティング
- 目的：企業内の最も基幹的な業務を従来通りの情報システム部門に任せ、各部門で必要となる細かな業務処理については、各部門で導入するコンピュータ(サーバ)とネットワーク環境(LAN)で、対応する
  - メインフレームの一点集中から、メインフレームを頂点として、各部門もサーバを保有し、さらに各担当もPCを使用するというコンピュータ利用の階層構造


- エンドユーザコンピューティングで使用されるプログラミング言語は、プログラミングのプロでなくても習得しやすく、また、手軽に実行できるような言語である必要がある->**BASICが適合**
- 言語のキーワードが、英語の単語とほとんど等しく、数値型や文字列型などを意識する必要のないようにバリアント型が用意されていて、これを使用すれば、データ型を意識することなく、プログラミングを行うことができるようになっている

#### BASICの普及の理由
- エンドユーザコンピューティング
- PCが企業や個人で使用されるようになったこと
  - オープンシステムのPCの普及によって、エンドユーザもプログラミングを行う環境になってきた

- 初期のPCではキャラクタベース(CUI)でのUI表示になっていたが、ビットマップディスプレイ(GUI)が主流になってきて、GUIベースの表示機能を持つ言語が登場するようになってきている

### Visual BasicとRAD環境
- **Visual Basic**：画面表示洋のコントロールが豊富で、優れたGUI表現能力を持つ
  - プログラム作成は **RAD(Rapid Application Development)** 環境を使用して行うことができる

BASICの登場によって、それまでのCOBOLなどによるプログラム作成と実行環境を劇的に変化させ、非常に多くのプログラマに使用されるようになった。ドラッグ&ドロップなど、実際のキー入力によるコード記述を組み合わせて行えることで、エンドユーザコンピューティングを実現する上でも有効な機能となった。


#### 開発モデルへの影響
1. ウォーターフォール・モデル：要件定義から、外部設計、内部設計書を作成し、プログラミング・テストを経てカットオーバ・運用へと進んでいく
   - 各作業ステップは基本的に並列で行われることはなく、前工程への後戻りは行われない
   - 長い時間かけてウォーターフォール・モデルで開発されたシステムがカットオーバされたときには、すでに開発されたアプリケーションの内容が古くなっていることが稀ではない
   - 要件定義では、実際のエンドユーザの要求を反映したものにしなければならないが、専門知識を持っているわけではないため、開発色に明確に要求として出すことができない
1. スパイラルモデル：要件定義から設計、製造・テストまでをスパイラルのように繰り返す
   - この方式では、最初の設計から開発は、使用が明確に確定していなくても、開発を行うことができる
   - 何度もエンドユーザに実際の画面イメージや操作手順をみてもらいながら、開発をすすめていくことができる
   - ユーザのイメージした要求内容と実際に開発されたシステムに食い違いがあったという問題も起こりにくくなる
   - 迅速にプログラム作成できるような開発環境が必要になる
   - BASICの容易さと、RAD環境を使用した開発の効率化とスポードアップがスパイラルでの開発を可能なものにしている
1. アジャイルモデル：開発の対象を多くの小さな機能に分割し、1つの反復で1つの機能を開発する
   - 要求分析から、設計、製造、テストといった、ソフトウェア開発の全工程を1つの反復内で行う
   - 個別モジュール単位で完成していくことが異なるため、開発スピードが要求される


   
